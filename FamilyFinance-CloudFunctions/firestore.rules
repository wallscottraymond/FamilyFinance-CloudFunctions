rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    
    // =======================
    // HELPER FUNCTIONS
    // =======================
    
    // Check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }
    
    // Get user role from custom claims
    function getUserRole() {
      return request.auth.token.role;
    }
    
    // Check if user has a specific role
    function hasRole(role) {
      return isAuthenticated() && getUserRole() == role;
    }
    
    // Check if user is admin
    function isAdmin() {
      return hasRole('admin');
    }
    
    // Check if user is parent
    function isParent() {
      return hasRole('parent');
    }
    
    // Check if user can manage (admin or parent)
    function canManage() {
      return isAdmin() || isParent();
    }
    
    // Check if user owns the resource
    function isOwner(resourceUserId) {
      return isAuthenticated() && request.auth.uid == resourceUserId;
    }
    
    // Check if user is in the same family
    function inSameFamily(familyId) {
      return isAuthenticated() && 
             exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
             get(/databases/$(database)/documents/users/$(request.auth.uid)).data.familyId == familyId;
    }
    
    // Check if user can access another user (same family or admin)
    function canAccessUser(targetUserId) {
      return isOwner(targetUserId) || 
             isAdmin() ||
             (exists(/databases/$(database)/documents/users/$(targetUserId)) &&
              inSameFamily(get(/databases/$(database)/documents/users/$(targetUserId)).data.familyId));
    }
    
    // Validate user data structure
    function isValidUserData() {
      let data = request.resource.data;
      return data.keys().hasAll(['email', 'displayName', 'role', 'isActive', 'preferences']) &&
             data.email is string && data.email.size() > 0 &&
             data.displayName is string && data.displayName.size() > 0 &&
             data.role is string && data.role in ['admin', 'parent', 'child', 'viewer'] &&
             data.isActive is bool &&
             isValidPreferences(data.preferences);
    }
    
    // Validate preferences structure
    function isValidPreferences(prefs) {
      return prefs.keys().hasAll(['currency', 'locale', 'theme', 'notifications', 'privacy', 'display', 'accessibility', 'financial', 'security']) &&
             prefs.currency is string && prefs.currency.size() == 3 &&
             prefs.locale is string && prefs.locale.size() > 0 &&
             prefs.theme is string && prefs.theme in ['light', 'dark', 'auto'] &&
             isValidNotificationSettings(prefs.notifications) &&
             isValidPrivacySettings(prefs.privacy) &&
             isValidDisplaySettings(prefs.display) &&
             isValidAccessibilitySettings(prefs.accessibility) &&
             isValidFinancialSettings(prefs.financial) &&
             isValidSecuritySettings(prefs.security);
    }
    
    // Validate notification settings
    function isValidNotificationSettings(notifs) {
      return notifs.keys().hasAll(['email', 'push', 'transactionAlerts', 'budgetAlerts', 'weeklyReports']) &&
             notifs.email is bool &&
             notifs.push is bool &&
             notifs.transactionAlerts is bool &&
             notifs.budgetAlerts is bool &&
             notifs.weeklyReports is bool;
    }
    
    // Validate privacy settings
    function isValidPrivacySettings(privacy) {
      return privacy.keys().hasAll(['shareSpendingWithFamily', 'shareGoalsWithFamily', 'allowFamilyToSeeTransactionDetails', 'showProfileToFamilyMembers', 'dataRetentionPeriod', 'allowAnalytics', 'allowMarketingEmails']) &&
             privacy.shareSpendingWithFamily is bool &&
             privacy.shareGoalsWithFamily is bool &&
             privacy.allowFamilyToSeeTransactionDetails is bool &&
             privacy.showProfileToFamilyMembers is bool &&
             privacy.dataRetentionPeriod is int && privacy.dataRetentionPeriod > 0 &&
             privacy.allowAnalytics is bool &&
             privacy.allowMarketingEmails is bool;
    }
    
    // Validate display settings
    function isValidDisplaySettings(display) {
      return display.keys().hasAll(['dateFormat', 'timeFormat', 'numberFormat', 'showCentsInDisplays', 'defaultTransactionView']) &&
             display.dateFormat is string && display.dateFormat in ['MM/DD/YYYY', 'DD/MM/YYYY', 'YYYY-MM-DD'] &&
             display.timeFormat is string && display.timeFormat in ['12h', '24h'] &&
             display.numberFormat is string && display.numberFormat in ['US', 'EU', 'IN'] &&
             display.showCentsInDisplays is bool &&
             display.defaultTransactionView is string && display.defaultTransactionView in ['list', 'cards', 'table'];
    }
    
    // Validate accessibility settings
    function isValidAccessibilitySettings(access) {
      return access.keys().hasAll(['fontSize', 'highContrast', 'reduceMotion', 'screenReaderOptimized', 'voiceOverEnabled', 'hapticFeedback', 'longPressDelay']) &&
             access.fontSize is string && access.fontSize in ['small', 'medium', 'large', 'extra_large'] &&
             access.highContrast is bool &&
             access.reduceMotion is bool &&
             access.screenReaderOptimized is bool &&
             access.voiceOverEnabled is bool &&
             access.hapticFeedback is bool &&
             access.longPressDelay is int && access.longPressDelay >= 100 && access.longPressDelay <= 2000;
    }
    
    // Validate financial settings
    function isValidFinancialSettings(financial) {
      return financial.keys().hasAll(['autoCategorizationEnabled', 'roundUpSavings', 'budgetStartDay', 'showNetWorth', 'hiddenAccounts', 'defaultBudgetAlertThreshold', 'enableSpendingLimits']) &&
             financial.autoCategorizationEnabled is bool &&
             financial.roundUpSavings is bool &&
             financial.budgetStartDay is int && financial.budgetStartDay >= 1 && financial.budgetStartDay <= 31 &&
             financial.showNetWorth is bool &&
             financial.hiddenAccounts is list &&
             financial.defaultBudgetAlertThreshold is int && financial.defaultBudgetAlertThreshold >= 0 && financial.defaultBudgetAlertThreshold <= 100 &&
             financial.enableSpendingLimits is bool;
    }
    
    // Validate security settings
    function isValidSecuritySettings(security) {
      return security.keys().hasAll(['biometricAuthEnabled', 'pinAuthEnabled', 'autoLockTimeout', 'requireAuthForTransactions', 'requireAuthForBudgetChanges', 'requireAuthForGoalChanges', 'sessionTimeout', 'allowedDevices', 'twoFactorAuthEnabled', 'suspiciousActivityDetection']) &&
             security.biometricAuthEnabled is bool &&
             security.pinAuthEnabled is bool &&
             security.autoLockTimeout is int && security.autoLockTimeout >= 0 &&
             security.requireAuthForTransactions is bool &&
             security.requireAuthForBudgetChanges is bool &&
             security.requireAuthForGoalChanges is bool &&
             security.sessionTimeout is int && security.sessionTimeout > 0 &&
             security.allowedDevices is list &&
             security.twoFactorAuthEnabled is bool &&
             security.suspiciousActivityDetection is bool;
    }
    
    // =======================
    // USERS COLLECTION RULES
    // =======================
    
    match /users/{userId} {
      // Allow users to read their own profile
      // Allow family members to read basic profile info (filtered by cloud function)
      // Allow admins to read any user profile
      allow read: if isOwner(userId) || 
                     isAdmin() || 
                     canAccessUser(userId);
      
      // Allow users to create their own profile (via auth trigger usually)
      // This is primarily for the createUserProfile cloud function
      allow create: if isOwner(userId) && 
                       isValidUserData() &&
                       request.resource.data.role == 'viewer'; // New users start as viewers
      
      // Allow users to update their own profile
      // Allow admins to update any user profile
      // Prevent role elevation without proper authorization
      allow update: if (isOwner(userId) || isAdmin()) &&
                       isValidUserData() &&
                       // Users cannot change their own role unless they're admin
                       (isOwner(userId) ? 
                         (request.resource.data.role == resource.data.role || isAdmin()) :
                         true) &&
                       // Prevent deactivating oneself unless admin
                       (isOwner(userId) ? 
                         (request.resource.data.isActive == true || isAdmin()) :
                         true);
      
      // Only admins can delete user profiles (soft delete preferred)
      allow delete: if isAdmin();
      
      // Subcollections for user-specific data
      match /sessions/{sessionId} {
        // Users can manage their own sessions
        allow read, write: if isOwner(userId);
        allow delete: if isOwner(userId) || isAdmin();
      }
      
      match /devices/{deviceId} {
        // Users can manage their own devices
        allow read, write: if isOwner(userId);
        allow delete: if isOwner(userId) || isAdmin();
      }
      
      match /preferences_history/{historyId} {
        // Users can read their preference history
        // Write access controlled by cloud functions
        allow read: if isOwner(userId);
        allow write: if false; // Only cloud functions should write history
      }
      
      match /plaidItems/{itemId} {
        // Users can manage their own Plaid items
        allow read: if isOwner(userId);
        allow create: if isOwner(userId) && isAuthenticated();
        allow update: if isOwner(userId) && isAuthenticated();
        allow delete: if isOwner(userId) || isAdmin();
      }
    }
    
    // =======================
    // FAMILIES COLLECTION RULES
    // =======================
    
    match /families/{familyId} {
      // Family members can read family data
      allow read: if inSameFamily(familyId);
      
      // Only authenticated users can create families (they become admin)
      allow create: if isAuthenticated() && 
                       request.resource.data.adminUserId == request.auth.uid;
      
      // Only family admin can update family settings
      allow update: if inSameFamily(familyId) && 
                       resource.data.adminUserId == request.auth.uid;
      
      // Only family admin can delete family
      allow delete: if resource.data.adminUserId == request.auth.uid;
    }
    
    // =======================
    // TRANSACTIONS COLLECTION RULES
    // =======================
    
    match /transactions/{transactionId} {
      // Users can read their own transactions
      // Family members can read family transactions if familyId is set
      allow read: if isOwner(resource.data.userId) || 
                     (resource.data.familyId != null && inSameFamily(resource.data.familyId));
      
      // SECURE: Only allow users to list their own transactions or family transactions
      // Users can read their own transactions
      // Family members can read family transactions if familyId is set
      allow list: if isAuthenticated() &&
                     (isOwner(resource.data.userId) ||
                      (resource.data.familyId != null && inSameFamily(resource.data.familyId)));
      
      // Users can create transactions for themselves
      // Parents/Admins can create for family members
      // Cloud functions can create Plaid transactions
      allow create: if isAuthenticated() &&
                       (isOwner(request.resource.data.userId) || canManage()) &&
                       isValidTransactionData();
      
      // Users can update their own transactions (splits, notes, visibility)
      // Parents/Admins can update family transactions
      // Temporarily simplified validation for debugging
      allow update: if isOwner(resource.data.userId) || 
                       (resource.data.familyId != null && canManage() && inSameFamily(resource.data.familyId));
      
      // Users can delete their own manual transactions
      // Admins can delete any transaction
      allow delete: if (isOwner(resource.data.userId) && resource.data.source != 'plaid') || 
                       isAdmin();
    }
    
    // =======================
    // BUDGETS COLLECTION RULES
    // =======================
    
    match /budgets/{budgetId} {
      // Family members can read family budgets
      allow read: if inSameFamily(resource.data.familyId);

      // Only parents/admins can create budgets with valid data
      allow create: if canManage() &&
                       inSameFamily(request.resource.data.familyId) &&
                       isValidBudgetData();

      // Only budget creator or family admin can update with valid data
      allow update: if (isOwner(resource.data.createdBy) ||
                        (resource.data.familyId == get(/databases/$(database)/documents/families/$(resource.data.familyId)).data.adminUserId == request.auth.uid)) &&
                       inSameFamily(resource.data.familyId) &&
                       isValidBudgetData();

      // Only family admin can delete budgets
      allow delete: if inSameFamily(resource.data.familyId) &&
                       get(/databases/$(database)/documents/families/$(resource.data.familyId)).data.adminUserId == request.auth.uid;
    }
    
    // =======================
    // NOTIFICATIONS COLLECTION RULES
    // =======================
    
    match /notifications/{notificationId} {
      // Users can read their own notifications
      allow read: if isOwner(resource.data.userId);
      
      // Only cloud functions should create notifications
      allow create: if false;
      
      // Users can mark their own notifications as read
      allow update: if isOwner(resource.data.userId) &&
                       request.resource.data.diff(resource.data).affectedKeys().hasOnly(['read', 'readAt']);
      
      // Users can delete their own notifications
      allow delete: if isOwner(resource.data.userId);
    }
    
    // =======================
    // SOURCE PERIODS COLLECTION RULES
    // =======================
    
    match /source_periods/{periodId} {
      // All authenticated users can read source periods (needed for budget creation)
      // Temporarily remove role dependency for debugging
      allow read: if request.auth != null;
      
      // Only admins can create/update/delete source periods
      allow create, update, delete: if isAdmin();
    }
    
    // =======================
    // ACCOUNTS COLLECTION RULES
    // =======================
    
    match /accounts/{accountId} {
      // Users can read their own accounts
      // Family members can read family accounts
      allow read: if isOwner(resource.data.userId) || 
                     (resource.data.familyId != null && inSameFamily(resource.data.familyId));
      
      // Only authenticated users can create their own accounts
      allow create: if isAuthenticated() &&
                       isOwner(request.resource.data.userId);
      
      // Users can update their own accounts
      // Admins can update any account
      allow update: if (isOwner(resource.data.userId) || isAdmin()) &&
                       // Prevent changing userId after creation
                       request.resource.data.userId == resource.data.userId;
      
      // Users can delete their own accounts
      // Admins can delete any account
      allow delete: if isOwner(resource.data.userId) || isAdmin();
    }

    // =======================
    // PLAID INTEGRATION COLLECTIONS
    // =======================
    
    match /plaid_items/{itemId} {
      // Users can read their own Plaid items
      // Family members can read basic item info (institution name, status)
      allow read: if isOwner(resource.data.userId) || 
                     (resource.data.familyId != null && inSameFamily(resource.data.familyId));
      
      // Only authenticated users can create their own Plaid items
      allow create: if isAuthenticated() &&
                       isOwner(request.resource.data.userId) &&
                       isValidPlaidItemData();
      
      // Users can update their own Plaid items
      // Admins can update any Plaid item for troubleshooting
      allow update: if (isOwner(resource.data.userId) || isAdmin()) &&
                       isValidPlaidItemData() &&
                       // Prevent changing userId after creation
                       request.resource.data.userId == resource.data.userId;
      
      // Users can delete their own Plaid items
      // Admins can delete any Plaid item
      allow delete: if isOwner(resource.data.userId) || isAdmin();
    }
    
    match /plaid_accounts/{accountId} {
      // Users can read their own Plaid accounts
      // Family members can read basic account info (name, type, balances)
      allow read: if isOwner(resource.data.userId) || 
                     (resource.data.familyId != null && inSameFamily(resource.data.familyId));
      
      // Only authenticated users can create their own Plaid accounts
      allow create: if isAuthenticated() &&
                       isOwner(request.resource.data.userId) &&
                       isValidPlaidAccountData();
      
      // Users can update their own Plaid accounts (sync settings, visibility)
      // Admins can update any Plaid account
      allow update: if (isOwner(resource.data.userId) || isAdmin()) &&
                       isValidPlaidAccountData() &&
                       // Prevent changing userId after creation
                       request.resource.data.userId == resource.data.userId;
      
      // Users can delete their own Plaid accounts
      // Admins can delete any Plaid account
      allow delete: if isOwner(resource.data.userId) || isAdmin();
    }
    
    match /plaid_transactions/{transactionId} {
      // Users can read their own Plaid transactions
      // Family members can read family transactions (filtered by cloud functions for privacy)
      allow read: if isOwner(resource.data.userId) || 
                     (resource.data.familyId != null && inSameFamily(resource.data.familyId));
      
      // Only cloud functions should create Plaid transactions (from sync)
      allow create: if false;
      
      // Users can update limited fields on their own transactions (user notes, tags, category overrides)
      allow update: if isOwner(resource.data.userId) &&
                       isValidPlaidTransactionUpdate();
      
      // Only admins can delete Plaid transactions (for cleanup)
      allow delete: if isAdmin();
    }
    
    match /plaid_webhooks/{webhookId} {
      // Only admins can read webhook logs (for debugging)
      allow read: if isAdmin();
      
      // Only cloud functions should create webhook records
      allow create: if false;
      
      // Only cloud functions should update webhook processing status
      allow update: if false;
      
      // Only admins can delete webhook records (for cleanup)
      allow delete: if isAdmin();
    }
    
    match /plaid_configuration/config {
      // Only admins can read Plaid configuration
      allow read: if isAdmin();
      
      // Only admins can update Plaid configuration
      allow create, update: if isAdmin() && isValidPlaidConfigData();
      
      // Only admins can delete Plaid configuration
      allow delete: if isAdmin();
    }
    
    match /plaid_recurring_transactions/{recurringTransactionId} {
      // Users can read their own recurring transactions
      // Family members can read family recurring transactions (filtered by cloud functions for privacy)
      allow read: if isOwner(resource.data.userId) || 
                     (resource.data.familyId != null && inSameFamily(resource.data.familyId));
      
      // Only cloud functions should create recurring transactions (from sync)
      allow create: if false;
      
      // Users can update limited fields on their own recurring transactions (user notes, tags, category overrides, visibility)
      allow update: if isOwner(resource.data.userId) &&
                       isValidPlaidRecurringTransactionUpdate();
      
      // Only admins can delete recurring transactions (for cleanup)
      allow delete: if isAdmin();
    }
    
    match /plaid_recurring_transaction_updates/{updateId} {
      // Only admins can read recurring transaction update logs (for debugging)
      allow read: if isAdmin();
      
      // Only cloud functions should create update records
      allow create: if false;
      
      // Only cloud functions should update processing status
      allow update: if false;
      
      // Only admins can delete update records (for cleanup)
      allow delete: if isAdmin();
    }
    
    // =======================
    // INFLOW COLLECTION RULES - ROOT LEVEL
    // =======================
    
    match /inflow/{inflowId} {
      // Users can read their own inflow streams
      // Family members can read family inflow streams (filtered by cloud functions for privacy)
      allow read: if isOwner(resource.data.userId) || 
                     (resource.data.familyId != null && inSameFamily(resource.data.familyId));
      
      // Only cloud functions should create inflow streams (from Plaid sync)
      allow create: if false;
      
      // Users can update limited fields on their own inflow streams (user notes, tags, category overrides, visibility)
      allow update: if isOwner(resource.data.userId) &&
                       isValidRecurringIncomeUpdate();
      
      // Only admins can delete inflow streams (for cleanup)
      allow delete: if isAdmin();
    }
    
    // =======================
    // OUTFLOWS COLLECTION RULES - ROOT LEVEL
    // =======================
    
    match /outflows/{outflowId} {
      // Users can read their own outflow streams
      // Family members can read family outflow streams (filtered by cloud functions for privacy)
      allow read: if isOwner(resource.data.userId) || 
                     (resource.data.familyId != null && inSameFamily(resource.data.familyId));
      
      // Only cloud functions should create outflow streams (from Plaid sync)
      allow create: if false;
      
      // Users can update limited fields on their own outflow streams (user notes, tags, category overrides, visibility)
      allow update: if isOwner(resource.data.userId) &&
                       isValidRecurringOutflowUpdate();
      
      // Only admins can delete outflow streams (for cleanup)
      allow delete: if isAdmin();
    }
    
    // =======================
    // OUTFLOW PERIODS COLLECTION RULES - ROOT LEVEL
    // =======================
    
    match /outflow_periods/{outflowPeriodId} {
      // Users can read their own outflow periods
      // Family members can read family outflow periods
      // Handle case where collection/documents don't exist yet
      allow read: if resource == null || 
                     isOwner(resource.data.userId) || 
                     (resource.data.familyId != null && inSameFamily(resource.data.familyId));
      
      // SECURE: Only allow users to list their own outflow periods or family outflow periods
      allow list: if isAuthenticated() &&
                     (isOwner(resource.data.userId) ||
                      (resource.data.familyId != null && inSameFamily(resource.data.familyId)));
      
      // Only cloud functions should create outflow periods (from onOutflowCreated trigger)
      allow create: if false;
      
      // Users can update limited fields on their own outflow periods (user modifications, notes)
      // Allow user to modify amounts if they're the owner
      allow update: if isOwner(resource.data.userId) &&
                       isValidOutflowPeriodUpdate();
      
      // Only admins can delete outflow periods (for cleanup)
      allow delete: if isAdmin();
    }
    
    // =======================
    // INFLOW PERIODS COLLECTION RULES - ROOT LEVEL
    // =======================
    
    match /inflow_periods/{inflowPeriodId} {
      // Users can read their own inflow periods
      // Family members can read family inflow periods
      // Handle case where collection/documents don't exist yet
      allow read: if resource == null || 
                     isOwner(resource.data.userId) || 
                     (resource.data.familyId != null && inSameFamily(resource.data.familyId));
      
      // SECURE: Only allow users to list their own inflow periods or family inflow periods
      // This covers cases where collection is empty or doesn't exist
      allow list: if isAuthenticated() &&
                     (isOwner(resource.data.userId) ||
                      (resource.data.familyId != null && inSameFamily(resource.data.familyId)));
      
      // Only cloud functions should create inflow periods (from onInflowCreated trigger)
      allow create: if false;
      
      // Users can update limited fields on their own inflow periods (user modifications, notes)
      // Allow user to modify amounts if they're the owner
      allow update: if isOwner(resource.data.userId) &&
                       isValidInflowPeriodUpdate();
      
      // Only admins can delete inflow periods (for cleanup)
      allow delete: if isAdmin();
    }
    
    // Validation functions for Plaid data
    function isValidPlaidItemData() {
      let data = request.resource.data;
      return data.keys().hasAll(['itemId', 'userId', 'institutionId', 'institutionName', 'accessToken', 'products', 'status', 'isActive']) &&
             data.itemId is string && data.itemId.size() > 0 &&
             data.userId is string && data.userId.size() > 0 &&
             data.institutionId is string && data.institutionId.size() > 0 &&
             data.institutionName is string && data.institutionName.size() > 0 &&
             data.accessToken is string && data.accessToken.size() > 0 &&
             data.products is list &&
             data.status is string && data.status in ['GOOD', 'ITEM_LOGIN_REQUIRED', 'PENDING_EXPIRATION', 'EXPIRED', 'ERROR'] &&
             data.isActive is bool &&
             // Ensure familyId matches user's family if provided
             (data.familyId == null || 
              (exists(/databases/$(database)/documents/users/$(data.userId)) &&
               get(/databases/$(database)/documents/users/$(data.userId)).data.familyId == data.familyId));
    }
    
    function isValidPlaidAccountData() {
      let data = request.resource.data;
      return data.keys().hasAll(['accountId', 'itemId', 'userId', 'name', 'type', 'subtype', 'balances', 'isActive', 'isSyncEnabled', 'metadata']) &&
             data.accountId is string && data.accountId.size() > 0 &&
             data.itemId is string && data.itemId.size() > 0 &&
             data.userId is string && data.userId.size() > 0 &&
             data.name is string && data.name.size() > 0 &&
             data.type is string && data.type in ['depository', 'credit', 'loan', 'investment', 'other'] &&
             data.subtype is string &&
             data.balances is map && data.balances.keys().hasAll(['current']) &&
             data.balances.current is number &&
             data.isActive is bool &&
             data.isSyncEnabled is bool &&
             data.metadata is map &&
             // Ensure familyId matches user's family if provided
             (data.familyId == null || 
              (exists(/databases/$(database)/documents/users/$(data.userId)) &&
               get(/databases/$(database)/documents/users/$(data.userId)).data.familyId == data.familyId));
    }
    
    function isValidPlaidTransactionUpdate() {
      let data = request.resource.data;
      let resource = resource.data;
      // Only allow updates to user-modifiable fields
      let allowedFields = ['userCategory', 'userNotes', 'tags', 'isHidden', 'updatedAt'];
      let changedFields = data.diff(resource).affectedKeys();
      return changedFields.hasOnly(allowedFields);
    }
    
    function isValidPlaidRecurringTransactionUpdate() {
      let data = request.resource.data;
      let resource_data = resource.data;
      // Only allow updates to user-modifiable fields for recurring transactions
      let allowedFields = ['userCategory', 'userNotes', 'tags', 'isHidden', 'updatedAt'];
      let changedFields = data.diff(resource_data).affectedKeys();
      return changedFields.hasOnly(allowedFields);
    }
    
    // Validation functions for new root collections
    function isValidRecurringIncomeUpdate() {
      let data = request.resource.data;
      let resource_data = resource.data;
      // Only allow updates to user-modifiable fields for income streams
      let allowedFields = [
        'userCategory', 'userNotes', 'tags', 'isHidden', 'updatedAt',
        'incomeType', 'isRegularSalary', 'employerName', 'taxable'
      ];
      let changedFields = data.diff(resource_data).affectedKeys();
      return changedFields.hasOnly(allowedFields);
    }
    
    function isValidRecurringOutflowUpdate() {
      let data = request.resource.data;
      let resource_data = resource.data;
      // Only allow updates to user-modifiable fields for outflow streams
      let allowedFields = [
        'userCategory', 'userNotes', 'tags', 'isHidden', 'updatedAt',
        'expenseType', 'isEssential', 'merchantCategory', 'isCancellable', 'reminderDays'
      ];
      let changedFields = data.diff(resource_data).affectedKeys();
      return changedFields.hasOnly(allowedFields);
    }
    
    // Validation function for outflow period updates
    function isValidOutflowPeriodUpdate() {
      let data = request.resource.data;
      let resource_data = resource.data;
      // Only allow updates to user-modifiable fields for outflow periods
      let allowedFields = [
        'userNotes', 'modifiedAmount', 'isModified', 'lastModifiedBy', 'lastModifiedAt', 'updatedAt'
      ];
      let changedFields = data.diff(resource_data).affectedKeys();
      return changedFields.hasOnly(allowedFields) &&
             // Ensure core immutable fields don't change
             data.outflowId == resource_data.outflowId &&
             data.periodId == resource_data.periodId &&
             data.userId == resource_data.userId &&
             data.billAmount == resource_data.billAmount &&
             data.dailyWithholdingRate == resource_data.dailyWithholdingRate;
    }
    
    // Validation function for inflow period updates
    function isValidInflowPeriodUpdate() {
      let data = request.resource.data;
      let resource_data = resource.data;
      // Only allow updates to user-modifiable fields for inflow periods
      let allowedFields = [
        'userNotes', 'modifiedAmount', 'isModified', 'lastModifiedBy', 'lastModifiedAt', 'updatedAt'
      ];
      let changedFields = data.diff(resource_data).affectedKeys();
      return changedFields.hasOnly(allowedFields) &&
             // Ensure core immutable fields don't change
             data.inflowId == resource_data.inflowId &&
             data.periodId == resource_data.periodId &&
             data.userId == resource_data.userId &&
             data.incomeAmount == resource_data.incomeAmount &&
             data.dailyEarningRate == resource_data.dailyEarningRate;
    }
    
    function isValidPlaidConfigData() {
      let data = request.resource.data;
      return data.keys().hasAll(['clientId', 'environment', 'products', 'countryCodes', 'isActive', 'syncSettings', 'encryptionSettings', 'errorHandling']) &&
             data.clientId is string && data.clientId.size() > 0 &&
             data.environment is string && data.environment in ['sandbox', 'development', 'production'] &&
             data.products is list &&
             data.countryCodes is list &&
             data.isActive is bool &&
             data.syncSettings is map && data.syncSettings.keys().hasAll(['maxTransactionDays', 'frontendTransactionDays', 'enableWebhooks', 'enableScheduledSync']) &&
             data.encryptionSettings is map && data.encryptionSettings.keys().hasAll(['algorithm', 'keyRotationDays']) &&
             data.errorHandling is map && data.errorHandling.keys().hasAll(['maxRetries', 'retryDelayMs', 'errorReportingEnabled']);
    }
    
    // Transaction validation functions
    function isValidTransactionData() {
      let data = request.resource.data;
      return data.keys().hasAll(['id', 'userId', 'amount', 'date', 'name', 'source', 'status']) &&
             data.id is string && data.id.size() > 0 &&
             data.userId is string && data.userId.size() > 0 &&
             data.amount is number &&
             data.date is string &&
             data.name is string && data.name.size() > 0 &&
             data.source is string && data.source in ['manual', 'plaid', 'import'] &&
             data.status is string && data.status in ['pending', 'posted', 'cleared'] &&
             data.isManual is bool &&
             (data.familyId == null || data.familyId is string);
    }

    // Budget validation function
    function isValidBudgetData() {
      let data = request.resource.data;
      return data.keys().hasAll(['name', 'amount', 'createdBy', 'isActive', 'isOngoing']) &&
             data.name is string && data.name.size() > 0 &&
             data.amount is number && data.amount > 0 &&
             data.createdBy is string && data.createdBy.size() > 0 &&
             data.isActive is bool &&
             data.isOngoing is bool &&
             // If isOngoing is false, budgetEndDate must be present and valid
             (data.isOngoing == true ||
              (data.keys().hasAny(['budgetEndDate']) && data.budgetEndDate is timestamp)) &&
             // Ensure budget end date is after start date if provided
             (!data.keys().hasAny(['budgetEndDate']) ||
              !data.keys().hasAny(['startDate']) ||
              data.budgetEndDate.toMillis() > data.startDate.toMillis());
    }
    
    function isValidTransactionUpdate() {
      let data = request.resource.data;
      let resource_data = resource.data;
      let changedFields = data.diff(resource_data).affectedKeys();
      
      // User-modifiable fields for transactions with embedded splits
      // Allow more flexible field updates to handle various transaction structures
      let allowedFields = [
        'userNotes',           // User notes
        'isHidden',            // Hide/show transaction
        'isRecurring',         // Mark as recurring
        'splits',              // Transaction splits array
        'isSplit',             // Split flag (calculated from splits)
        'totalAllocated',      // Total split amount (calculated)
        'unallocated',         // Unallocated amount (calculated)
        'affectedBudgets',     // Array of budget IDs
        'affectedBudgetPeriods', // Array of budget period IDs
        'primaryBudgetId',     // Primary budget ID (largest split)
        'primaryBudgetPeriodId', // Primary budget period ID (largest split)
        'updatedAt',           // Update timestamp
        // Additional fields that might be updated
        'lastSyncedAt',        // Last sync timestamp
        'tags',                // Transaction tags
        'category',            // Transaction category
        'userCategory',        // User override category
        'notes',               // Alternative notes field name
        'metadata'             // Metadata updates
      ];
      
      // Validate that only allowed fields are being changed
      let validFieldChanges = changedFields.hasOnly(allowedFields);
      
      // Prevent changing core immutable fields (if they exist)
      let coreFieldsUnchanged = (!('userId' in data) || data.userId == resource_data.userId) &&
                               (!('amount' in data) || data.amount == resource_data.amount);
      
      // For now, skip complex split validation to get basic updates working
      // We'll rely on the frontend/backend validation instead
      let splitsValid = true;
      
      return validFieldChanges && coreFieldsUnchanged && splitsValid;
    }
    
    // Validate transaction splits array
    function isValidTransactionSplitsUpdate(splits, transactionAmount) {
      return splits is list &&
             splits.size() >= 1 && // Must have at least one split
             splits.size() <= 20 && // Reasonable limit
             splits.all(split, isValidTransactionSplit(split)) &&
             isValidSplitAmounts(splits, transactionAmount);
    }
    
    // Validate individual transaction split with enhanced status fields
    function isValidTransactionSplit(split) {
      return split is map &&
             // Core required fields
             split.keys().hasAll(['id', 'categoryId', 'amount', 'isDefault', 'createdAt', 'updatedAt', 'createdBy']) &&
             split.id is string && split.id.size() > 0 &&
             split.categoryId is string &&
             split.amount is number && split.amount > 0 &&
             split.isDefault is bool &&
             split.createdAt is timestamp &&
             split.updatedAt is timestamp &&
             split.createdBy is string && split.createdBy.size() > 0 &&

             // Budget assignment fields (optional for unassigned splits)
             (!split.keys().hasAny(['budgetId']) || (split.budgetId is string && split.budgetId.size() > 0)) &&
             (!split.keys().hasAny(['budgetPeriodId']) || (split.budgetPeriodId is string && split.budgetPeriodId.size() > 0)) &&
             (!split.keys().hasAny(['budgetName']) || (split.budgetName is string && split.budgetName.size() > 0)) &&

             // Status fields validation
             isValidSplitStatusFields(split) &&

             // Optional fields validation
             (!split.keys().hasAny(['description']) || split.description is string) &&
             (!split.keys().hasAny(['userNotes']) || split.userNotes is string);
    }

    // Enhanced validation for split status fields
    function isValidSplitStatusFields(split) {
      return (
        // Ignored status validation
        (!split.keys().hasAny(['isIgnored']) || split.isIgnored is bool) &&
        (!split.keys().hasAny(['ignoredReason']) || (split.ignoredReason is string && split.ignoredReason.size() <= 200)) &&

        // Refund status validation
        (!split.keys().hasAny(['isRefund']) || split.isRefund is bool) &&
        (!split.keys().hasAny(['refundReason']) || (split.refundReason is string && split.refundReason.size() <= 200)) &&

        // Tax deductible status validation
        (!split.keys().hasAny(['isTaxDeductible']) || split.isTaxDeductible is bool) &&
        (!split.keys().hasAny(['taxDeductibleCategory']) || (split.taxDeductibleCategory is string && split.taxDeductibleCategory.size() <= 100)) &&

        // Budget exclusion validation
        (!split.keys().hasAny(['excludedFromBudgets']) || split.excludedFromBudgets is bool) &&

        // Manual budget assignment validation
        (!split.keys().hasAny(['manualBudgetAssignment']) || split.manualBudgetAssignment is bool) &&

        // Status consistency checks
        isValidSplitStatusConsistency(split)
      );
    }

    // Validate status field consistency
    function isValidSplitStatusConsistency(split) {
      return (
        // If ignored reason is provided, isIgnored must be true
        (!split.keys().hasAny(['ignoredReason']) || split.get('isIgnored', false) == true) &&

        // If refund reason is provided, isRefund must be true
        (!split.keys().hasAny(['refundReason']) || split.get('isRefund', false) == true) &&

        // If tax deductible category is provided, isTaxDeductible must be true
        (!split.keys().hasAny(['taxDeductibleCategory']) || split.get('isTaxDeductible', false) == true)
      );
    }
    
    // Validate that split amounts don't exceed transaction amount
    function isValidSplitAmounts(splits, transactionAmount) {
      // Calculate total of split amounts
      let totalSplitAmount = 0;
      // Use a simple iteration approach since complex aggregation in .all() is tricky
      return splits.size() > 0 && 
             splits.all(split, split.amount > 0 && split.amount <= transactionAmount * 1.1); // Allow 10% tolerance for floating point
    }
    
    // Validate budget period updates
    function isValidBudgetPeriodUpdate() {
      let data = request.resource.data;
      let resource_data = resource.data;
      
      // Allow updates to user-modifiable fields for budget periods
      let allowedFields = [
        'userNotes',           // User notes
        'modifiedAmount',      // Modified budget amount
        'isModified',          // Modification flag
        'isActive',            // Active/inactive status
        'lastModifiedBy',      // Who modified it
        'lastModifiedAt',      // When modified
        'checklistItems',      // Checklist items array
        'updatedAt'            // Update timestamp
      ];
      
      let changedFields = data.diff(resource_data).affectedKeys();
      let validFieldChanges = changedFields.hasOnly(allowedFields);
      
      // Ensure core immutable fields don't change
      let coreFieldsUnchanged = data.budgetId == resource_data.budgetId &&
                               data.periodId == resource_data.periodId &&
                               data.userId == resource_data.userId &&
                               data.allocatedAmount == resource_data.allocatedAmount &&
                               data.originalAmount == resource_data.originalAmount;
      
      // Validate checklist items if they're being updated
      let checklistValid = !changedFields.hasAny(['checklistItems']) || isValidChecklistItems(data.checklistItems);
      
      return validFieldChanges && coreFieldsUnchanged && checklistValid;
    }
    
    // Validate checklist items array
    function isValidChecklistItems(checklistItems) {
      return checklistItems is list &&
             checklistItems.size() <= 20 && // Reasonable limit
             checklistItems.all(item, isValidChecklistItem(item));
    }
    
    // Validate individual checklist item
    function isValidChecklistItem(item) {
      return item is map &&
             item.keys().hasAll(['id', 'name', 'transactionSplit', 'expectedAmount', 'actualAmount', 'isChecked']) &&
             item.id is string && item.id.size() > 0 &&
             item.name is string && item.name.size() > 0 && item.name.size() <= 100 &&
             item.transactionSplit is string &&
             item.expectedAmount is number && item.expectedAmount >= 0 &&
             item.actualAmount is number && item.actualAmount >= 0 &&
             item.isChecked is bool;
    }
    
    // =======================
    // BUDGET PERIODS COLLECTION RULES
    // =======================
    
    match /budget_periods/{budgetPeriodId} {
      // Users can read their own budget periods OR family members can read shared budget periods
      allow read: if isOwner(resource.data.userId) || 
                     (resource.data.familyId != null && inSameFamily(resource.data.familyId));
      
      // Budget creator can always manage their own budget_periods (regardless of role)
      // OR family managers (admin/parent) can manage any family budget_periods
      allow create, update: if (isOwner(resource.data.userId) || 
                                (canManage() && resource.data.familyId != null && inSameFamily(resource.data.familyId))) &&
                               isValidBudgetPeriodUpdate();
      
      // Only admins can delete budget periods (for cleanup)
      allow delete: if isAdmin();
    }
    
    
    // =======================
    // CATEGORIES COLLECTION RULES
    // =======================
    
    match /categories/{categoryId} {
      // All authenticated users can read categories (universal data)
      allow read: if isAuthenticated();
      
      // Only admins can create, update, or delete categories
      allow create, update, delete: if isAdmin();
    }
    
    // =======================
    // SYSTEM COLLECTIONS
    // =======================
    
    // Admin-only collections
    match /admin/{document=**} {
      allow read, write: if isAdmin();
    }
    
    // Analytics and logs (read-only for admins)
    match /analytics/{document=**} {
      allow read: if isAdmin();
      allow write: if false; // Only cloud functions
    }
    
    match /audit_logs/{document=**} {
      allow read: if isAdmin();
      allow write: if false; // Only cloud functions
    }
    
    // Deny all other requests
    match /{document=**} {
      allow read, write: if false;
    }
  }
}