# Transaction ID Migration Fix

## Issue

When we migrated to use Plaid transaction IDs as Firestore document IDs, we only updated the transaction sync code to create **new** transactions with the Plaid ID as the document ID. However, **old transactions** that were created before this change still have auto-generated Firebase document IDs.

### Before the Migration
- Document ID: Auto-generated by Firebase (e.g., `abc123xyz`)
- `metadata.plaidTransactionId`: Contains the Plaid transaction ID

### After the Migration
- Document ID: Plaid transaction ID (e.g., `plaid_txn_abc123`)
- `metadata.plaidTransactionId`: Also contains the Plaid transaction ID

## Problem

The `autoMatchTransactionToOutflowPeriods` function was only checking for transactions using the document ID approach:

```typescript
// Only worked for NEW transactions
const promises = batchIds.map(id => db.collection('transactions').doc(id).get());
```

This meant:
- ✅ NEW transactions (created after migration) were found correctly
- ❌ OLD transactions (created before migration) were NOT found
- ❌ Outflow auto-matching failed silently for old transactions

## Solution

Updated `getTransactionsByPlaidIds()` in `/src/functions/outflows/utils/autoMatchTransactionToOutflowPeriods.ts` to use a **two-step approach**:

### Step 1: Try Direct Document Lookup (NEW format)
```typescript
const promises = batchIds.map(id => db.collection('transactions').doc(id).get());
const docs = await Promise.all(promises);
```

### Step 2: Fallback to Metadata Query (OLD format)
```typescript
const notFoundIds = batchIds.filter(id => !foundIds.has(id));
if (notFoundIds.length > 0) {
  const querySnapshot = await db.collection('transactions')
    .where('userId', '==', userId)
    .where('metadata.plaidTransactionId', 'in', notFoundIds)
    .get();
}
```

## Files Changed

1. **`/src/functions/outflows/utils/autoMatchTransactionToOutflowPeriods.ts`** (lines 139-197)
   - Updated `getTransactionsByPlaidIds()` function
   - Added two-step lookup logic
   - Added logging for debugging

2. **`/src/functions/outflows/admin/debugTransactionMatching.ts`** (NEW FILE)
   - Created debug function to diagnose matching issues
   - Usage: `GET /debugTransactionMatching?outflowId=OUTFLOW_ID`
   - Exported in `/src/functions/outflows/admin/index.ts`

## Testing

### Using the Debug Function

1. **Deploy the new debug function:**
   ```bash
   firebase deploy --only functions:debugTransactionMatching
   ```

2. **Call the debug function with an outflow ID:**
   ```bash
   curl "https://us-central1-YOUR_PROJECT.cloudfunctions.net/debugTransactionMatching?outflowId=OUTFLOW_ID"
   ```

3. **Interpret the results:**
   - `foundAsDocumentId`: Transactions found using NEW format (Plaid ID as doc ID)
   - `foundViaQuery`: Transactions found using OLD format (query by metadata)
   - `notFound`: Transactions that don't exist in database at all

### Expected Results After Fix

- **Before fix:** `foundAsDocumentId: 0`, `foundViaQuery: N`, `notFound: 0`
- **After fix:** All transactions found via one method or the other

## Deployment

```bash
# Build
npm run build

# Deploy (choose one)
firebase deploy --only functions                                    # Deploy all functions
firebase deploy --only functions:onOutflowCreated                   # Just the trigger
firebase deploy --only functions:debugTransactionMatching           # Just the debug tool
```

## Future Considerations

### Option 1: Keep Backwards Compatibility (Current Approach)
- ✅ Works with both old and new transactions
- ✅ No data migration required
- ✅ Safe and non-disruptive
- ❌ Slightly slower (two queries for old transactions)
- ❌ Code complexity to maintain both formats

### Option 2: Migrate All Old Transactions
Create a one-time migration script to update all old transactions:

```typescript
// Migration script (pseudocode)
const oldTransactions = await db.collection('transactions')
  .where('metadata.source', '==', 'plaid')
  .get();

for (const doc of oldTransactions.docs) {
  const data = doc.data();
  const plaidTxnId = data.metadata.plaidTransactionId;

  // Create new document with Plaid ID as document ID
  await db.collection('transactions').doc(plaidTxnId).set(data);

  // Delete old document
  await doc.ref.delete();
}
```

**Migration Considerations:**
- Would need to run during low-traffic period
- Must update all references in other collections (budget_periods, outflow_periods, etc.)
- Risk of data loss if interrupted
- Requires extensive testing

### Recommendation

**Keep the current backwards-compatible approach** until:
1. All old transactions naturally age out (6-12 months)
2. You're ready to do a comprehensive data migration with proper testing
3. The performance impact becomes significant

## Performance Impact

### Query Performance
- **NEW transactions:** 1 direct document lookup (~10ms)
- **OLD transactions:** 2 queries (direct + metadata query, ~20-30ms)
- **Impact:** Minimal - only affects initial outflow creation/auto-matching

### Optimization
The function already implements:
- ✅ Batch processing (10 IDs at a time)
- ✅ Early exit if all transactions found in Step 1
- ✅ Deduplication to avoid processing same transaction twice
- ✅ User ID verification for security

## Related Documentation

- **Plaid Integration:** `/CLAUDE.md` (Plaid Integration Architecture section)
- **Outflows System:** `/src/functions/outflows/CLAUDE.md`
- **Transaction Splits:** `/PLAID_SPLITS_INTEGRATION_SUMMARY.md`

## Notes

- This fix maintains full backwards compatibility
- No breaking changes to existing functionality
- Safe to deploy immediately
- Debug function helps verify the fix is working correctly
