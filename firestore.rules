rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    
    // =======================
    // HELPER FUNCTIONS
    // =======================
    
    // Check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }
    
    // Get user role from custom claims
    function getUserRole() {
      return request.auth.token.role;
    }
    
    // Check if user has a specific role
    function hasRole(role) {
      return isAuthenticated() && getUserRole() == role;
    }
    
    // Check if user is admin
    function isAdmin() {
      return hasRole('admin');
    }
    
    // Check if user is parent
    function isParent() {
      return hasRole('parent');
    }
    
    // Check if user can manage (admin or parent)
    function canManage() {
      return isAdmin() || isParent();
    }
    
    // Check if user owns the resource
    function isOwner(resourceUserId) {
      return isAuthenticated() && request.auth.uid == resourceUserId;
    }
    
    // Check if user is in the same family
    function inSameFamily(familyId) {
      return isAuthenticated() &&
             exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
             get(/databases/$(database)/documents/users/$(request.auth.uid)).data.familyId == familyId;
    }

    // Check if user belongs to any of the document's groups
    function canAccessGroup(documentGroupIds) {
      return isAuthenticated() &&
             documentGroupIds != null &&
             documentGroupIds.size() > 0 &&
             exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
             hasAnyGroupAccess(get(/databases/$(database)/documents/users/$(request.auth.uid)).data.groupIds, documentGroupIds);
    }

    // Check if user's groups intersect with document's groups
    function hasAnyGroupAccess(userGroupIds, documentGroupIds) {
      return userGroupIds != null &&
             userGroupIds.hasAny(documentGroupIds);
    }

    // Check if user belongs to group extracted from summary ID
    // Summary ID format: {groupId}_{periodType} (e.g., "group_xyz789_monthly")
    function userBelongsToGroupFromSummaryId(summaryId) {
      let groupId = summaryId.split('_')[0];
      return exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
             get(/databases/$(database)/documents/users/$(request.auth.uid)).data.groupIds.hasAny([groupId]);
    }

    // Check if user can access another user (same family or admin)
    function canAccessUser(targetUserId) {
      return isOwner(targetUserId) || 
             isAdmin() ||
             (exists(/databases/$(database)/documents/users/$(targetUserId)) &&
              inSameFamily(get(/databases/$(database)/documents/users/$(targetUserId)).data.familyId));
    }
    
    // Validate user data structure
    function isValidUserData() {
      let data = request.resource.data;
      return data.keys().hasAll(['email', 'displayName', 'role', 'isActive', 'preferences']) &&
             data.email is string && data.email.size() > 0 &&
             data.displayName is string && data.displayName.size() > 0 &&
             data.role is string && data.role in ['admin', 'parent', 'child', 'viewer'] &&
             data.isActive is bool &&
             isValidPreferences(data.preferences);
    }
    
    // Validate preferences structure
    function isValidPreferences(prefs) {
      return prefs.keys().hasAll(['currency', 'locale', 'theme', 'notifications', 'privacy', 'display', 'accessibility', 'financial', 'security']) &&
             prefs.currency is string && prefs.currency.size() == 3 &&
             prefs.locale is string && prefs.locale.size() > 0 &&
             prefs.theme is string && prefs.theme in ['light', 'dark', 'auto'] &&
             isValidNotificationSettings(prefs.notifications) &&
             isValidPrivacySettings(prefs.privacy) &&
             isValidDisplaySettings(prefs.display) &&
             isValidAccessibilitySettings(prefs.accessibility) &&
             isValidFinancialSettings(prefs.financial) &&
             isValidSecuritySettings(prefs.security);
    }
    
    // Validate notification settings
    function isValidNotificationSettings(notifs) {
      return notifs.keys().hasAll(['email', 'push', 'transactionAlerts', 'budgetAlerts', 'weeklyReports']) &&
             notifs.email is bool &&
             notifs.push is bool &&
             notifs.transactionAlerts is bool &&
             notifs.budgetAlerts is bool &&
             notifs.weeklyReports is bool;
    }
    
    // Validate privacy settings
    function isValidPrivacySettings(privacy) {
      return privacy.keys().hasAll(['shareSpendingWithFamily', 'shareGoalsWithFamily', 'allowFamilyToSeeTransactionDetails', 'showProfileToFamilyMembers', 'dataRetentionPeriod', 'allowAnalytics', 'allowMarketingEmails']) &&
             privacy.shareSpendingWithFamily is bool &&
             privacy.shareGoalsWithFamily is bool &&
             privacy.allowFamilyToSeeTransactionDetails is bool &&
             privacy.showProfileToFamilyMembers is bool &&
             privacy.dataRetentionPeriod is int && privacy.dataRetentionPeriod > 0 &&
             privacy.allowAnalytics is bool &&
             privacy.allowMarketingEmails is bool;
    }
    
    // Validate display settings
    function isValidDisplaySettings(display) {
      return display.keys().hasAll(['dateFormat', 'timeFormat', 'numberFormat', 'showCentsInDisplays', 'defaultTransactionView']) &&
             display.dateFormat is string && display.dateFormat in ['MM/DD/YYYY', 'DD/MM/YYYY', 'YYYY-MM-DD'] &&
             display.timeFormat is string && display.timeFormat in ['12h', '24h'] &&
             display.numberFormat is string && display.numberFormat in ['US', 'EU', 'IN'] &&
             display.showCentsInDisplays is bool &&
             display.defaultTransactionView is string && display.defaultTransactionView in ['list', 'cards', 'table'];
    }
    
    // Validate accessibility settings
    function isValidAccessibilitySettings(access) {
      return access.keys().hasAll(['fontSize', 'highContrast', 'reduceMotion', 'screenReaderOptimized', 'voiceOverEnabled', 'hapticFeedback', 'longPressDelay']) &&
             access.fontSize is string && access.fontSize in ['small', 'medium', 'large', 'extra_large'] &&
             access.highContrast is bool &&
             access.reduceMotion is bool &&
             access.screenReaderOptimized is bool &&
             access.voiceOverEnabled is bool &&
             access.hapticFeedback is bool &&
             access.longPressDelay is int && access.longPressDelay >= 100 && access.longPressDelay <= 2000;
    }
    
    // Validate financial settings
    function isValidFinancialSettings(financial) {
      return financial.keys().hasAll(['autoCategorizationEnabled', 'roundUpSavings', 'budgetStartDay', 'showNetWorth', 'hiddenAccounts', 'defaultBudgetAlertThreshold', 'enableSpendingLimits']) &&
             financial.autoCategorizationEnabled is bool &&
             financial.roundUpSavings is bool &&
             financial.budgetStartDay is int && financial.budgetStartDay >= 1 && financial.budgetStartDay <= 31 &&
             financial.showNetWorth is bool &&
             financial.hiddenAccounts is list &&
             financial.defaultBudgetAlertThreshold is int && financial.defaultBudgetAlertThreshold >= 0 && financial.defaultBudgetAlertThreshold <= 100 &&
             financial.enableSpendingLimits is bool;
    }
    
    // Validate security settings
    function isValidSecuritySettings(security) {
      return security.keys().hasAll(['biometricAuthEnabled', 'pinAuthEnabled', 'autoLockTimeout', 'requireAuthForTransactions', 'requireAuthForBudgetChanges', 'requireAuthForGoalChanges', 'sessionTimeout', 'allowedDevices', 'twoFactorAuthEnabled', 'suspiciousActivityDetection']) &&
             security.biometricAuthEnabled is bool &&
             security.pinAuthEnabled is bool &&
             security.autoLockTimeout is int && security.autoLockTimeout >= 0 &&
             security.requireAuthForTransactions is bool &&
             security.requireAuthForBudgetChanges is bool &&
             security.requireAuthForGoalChanges is bool &&
             security.sessionTimeout is int && security.sessionTimeout > 0 &&
             security.allowedDevices is list &&
             security.twoFactorAuthEnabled is bool &&
             security.suspiciousActivityDetection is bool;
    }
    
    // =======================
    // USERS COLLECTION RULES
    // =======================
    
    match /users/{userId} {
      // Allow users to read their own profile
      // Allow family members to read basic profile info (filtered by cloud function)
      // Allow admins to read any user profile
      allow read: if isOwner(userId) || 
                     isAdmin() || 
                     canAccessUser(userId);
      
      // Allow users to create their own profile (via auth trigger usually)
      // This is primarily for the createUserProfile cloud function
      allow create: if isOwner(userId) && 
                       isValidUserData() &&
                       request.resource.data.role == 'viewer'; // New users start as viewers
      
      // Allow users to update their own profile
      // Allow admins to update any user profile
      // Prevent role elevation without proper authorization
      allow update: if (isOwner(userId) || isAdmin()) &&
                       isValidUserData() &&
                       // Users cannot change their own role unless they're admin
                       (isOwner(userId) ? 
                         (request.resource.data.role == resource.data.role || isAdmin()) :
                         true) &&
                       // Prevent deactivating oneself unless admin
                       (isOwner(userId) ? 
                         (request.resource.data.isActive == true || isAdmin()) :
                         true);
      
      // Only admins can delete user profiles (soft delete preferred)
      allow delete: if isAdmin();
      
      // Subcollections for user-specific data
      match /sessions/{sessionId} {
        // Users can manage their own sessions
        allow read, write: if isOwner(userId);
        allow delete: if isOwner(userId) || isAdmin();
      }
      
      match /devices/{deviceId} {
        // Users can manage their own devices
        allow read, write: if isOwner(userId);
        allow delete: if isOwner(userId) || isAdmin();
      }
      
      match /preferences_history/{historyId} {
        // Users can read their preference history
        // Write access controlled by cloud functions
        allow read: if isOwner(userId);
        allow write: if false; // Only cloud functions should write history
      }
      
      match /plaidItems/{itemId} {
        // Users can manage their own Plaid items
        allow read: if isOwner(userId);
        allow create: if isOwner(userId) && isAuthenticated();
        allow update: if isOwner(userId) && isAuthenticated();
        allow delete: if isOwner(userId) || isAdmin();
      }
    }
    
    // =======================
    // FAMILIES COLLECTION RULES
    // =======================
    
    match /families/{familyId} {
      // Family members can read family data
      allow read: if inSameFamily(familyId);
      
      // Only authenticated users can create families (they become admin)
      allow create: if isAuthenticated() && 
                       request.resource.data.adminUserId == request.auth.uid;
      
      // Only family admin can update family settings
      allow update: if inSameFamily(familyId) && 
                       resource.data.adminUserId == request.auth.uid;
      
      // Only family admin can delete family
      allow delete: if resource.data.adminUserId == request.auth.uid;
    }
    
    // =======================
    // TRANSACTIONS COLLECTION RULES
    // =======================
    
    match /transactions/{transactionId} {
      // Group-based access: Users can read transactions they have access to via groupId
      // NEW FLAT STRUCTURE: Uses ownerId and groupId at root level
      allow read: if isAuthenticated() && (
                     isOwner(resource.data.ownerId) ||
                     (resource.data.groupId != null && inSameFamily(resource.data.groupId))
                  );

      // Group-based access: Allow list queries using groupId
      // This supports queries on groupId for efficient group-based filtering
      allow list: if isAuthenticated();

      // Users can create transactions for themselves
      // Parents/Admins can create for family members
      // Cloud functions can create Plaid transactions
      // NEW FLAT STRUCTURE: Uses ownerId and groupId
      allow create: if isAuthenticated() &&
                       (isOwner(request.resource.data.ownerId) || canManage()) &&
                       isValidTransactionData();

      // Users can update their own transactions (splits, notes, visibility)
      // Parents/Admins can update family transactions
      // NEW FLAT STRUCTURE: Uses ownerId and groupId
      allow update: if isAuthenticated() && (
                       isOwner(resource.data.ownerId) ||
                       (resource.data.groupId != null && canManage() && inSameFamily(resource.data.groupId))
                    );

      // Users can delete their own manual transactions
      // Admins can delete any transaction
      // NEW FLAT STRUCTURE: Uses ownerId
      allow delete: if (isOwner(resource.data.ownerId) && resource.data.source != 'plaid') ||
                       isAdmin();
    }
    
    // =======================
    // BUDGETS COLLECTION RULES
    // =======================
    
    match /budgets/{budgetId} {
      // Group-based access: Users can read budgets in their groups
      // Falls back to familyId for legacy budgets
      allow read: if isOwner(resource.data.userId) ||
                     canAccessGroup(resource.data.groupIds) ||
                     (resource.data.familyId != null && inSameFamily(resource.data.familyId));

      // Only parents/admins can create budgets with valid data
      allow create: if canManage() &&
                       isValidBudgetData();

      // Only budget creator or family admin can update with valid data
      // Group-based access: Check groupIds array
      allow update: if (isOwner(resource.data.createdBy) ||
                        canAccessGroup(resource.data.groupIds) ||
                        (resource.data.familyId != null &&
                         get(/databases/$(database)/documents/families/$(resource.data.familyId)).data.adminUserId == request.auth.uid)) &&
                       isValidBudgetData();

      // Only family admin or group admins can delete budgets
      allow delete: if isAdmin() ||
                       canAccessGroup(resource.data.groupIds) ||
                       (resource.data.familyId != null &&
                        get(/databases/$(database)/documents/families/$(resource.data.familyId)).data.adminUserId == request.auth.uid);
    }
    
    // =======================
    // NOTIFICATIONS COLLECTION RULES
    // =======================
    
    match /notifications/{notificationId} {
      // Users can read their own notifications
      allow read: if isOwner(resource.data.userId);
      
      // Only cloud functions should create notifications
      allow create: if false;
      
      // Users can mark their own notifications as read
      allow update: if isOwner(resource.data.userId) &&
                       request.resource.data.diff(resource.data).affectedKeys().hasOnly(['read', 'readAt']);
      
      // Users can delete their own notifications
      allow delete: if isOwner(resource.data.userId);
    }
    
    // =======================
    // SOURCE PERIODS COLLECTION RULES
    // =======================
    
    match /source_periods/{periodId} {
      // All authenticated users can read source periods (needed for budget creation)
      // Temporarily remove role dependency for debugging
      allow read: if request.auth != null;
      
      // Only admins can create/update/delete source periods
      allow create, update, delete: if isAdmin();
    }
    
    // =======================
    // ACCOUNTS COLLECTION RULES
    // =======================
    
    match /accounts/{accountId} {
      // Group-based access: Users can read their own accounts or group-shared accounts
      // Falls back to familyId for legacy accounts
      allow read: if isOwner(resource.data.userId) ||
                     canAccessGroup(resource.data.groupIds) ||
                     (resource.data.familyId != null && inSameFamily(resource.data.familyId));

      // Only authenticated users can create their own accounts
      allow create: if isAuthenticated() &&
                       isOwner(request.resource.data.userId);

      // Users can update their own accounts
      // Group members can update shared accounts
      // Admins can update any account
      allow update: if (isOwner(resource.data.userId) ||
                        canAccessGroup(resource.data.groupIds) ||
                        isAdmin()) &&
                       // Prevent changing userId after creation
                       request.resource.data.userId == resource.data.userId;

      // Users can delete their own accounts
      // Admins can delete any account
      allow delete: if isOwner(resource.data.userId) || isAdmin();
    }

    // =======================
    // PLAID INTEGRATION COLLECTIONS
    // =======================
    
    match /plaid_items/{itemId} {
      // Group-based access: Users can read their own Plaid items or group-shared items
      // Falls back to familyId for legacy items
      allow read: if isOwner(resource.data.userId) ||
                     canAccessGroup(resource.data.groupIds) ||
                     (resource.data.familyId != null && inSameFamily(resource.data.familyId));

      // Only authenticated users can create their own Plaid items
      allow create: if isAuthenticated() &&
                       isOwner(request.resource.data.userId) &&
                       isValidPlaidItemData();

      // Users can update their own Plaid items
      // Group members can update shared items
      // Admins can update any Plaid item for troubleshooting
      allow update: if (isOwner(resource.data.userId) ||
                        canAccessGroup(resource.data.groupIds) ||
                        isAdmin()) &&
                       isValidPlaidItemData() &&
                       // Prevent changing userId after creation
                       request.resource.data.userId == resource.data.userId;

      // Users can delete their own Plaid items
      // Admins can delete any Plaid item
      allow delete: if isOwner(resource.data.userId) || isAdmin();
    }

    match /plaid_accounts/{accountId} {
      // Group-based access: Users can read their own Plaid accounts or group-shared accounts
      // Falls back to familyId for legacy accounts
      allow read: if isOwner(resource.data.userId) ||
                     canAccessGroup(resource.data.groupIds) ||
                     (resource.data.familyId != null && inSameFamily(resource.data.familyId));

      // Only authenticated users can create their own Plaid accounts
      allow create: if isAuthenticated() &&
                       isOwner(request.resource.data.userId) &&
                       isValidPlaidAccountData();

      // Users can update their own Plaid accounts (sync settings, visibility)
      // Group members can update shared accounts
      // Admins can update any Plaid account
      allow update: if (isOwner(resource.data.userId) ||
                        canAccessGroup(resource.data.groupIds) ||
                        isAdmin()) &&
                       isValidPlaidAccountData() &&
                       // Prevent changing userId after creation
                       request.resource.data.userId == resource.data.userId;

      // Users can delete their own Plaid accounts
      // Admins can delete any Plaid account
      allow delete: if isOwner(resource.data.userId) || isAdmin();
    }

    match /plaid_transactions/{transactionId} {
      // Group-based access: Users can read their own Plaid transactions or group-shared transactions
      // Falls back to familyId for legacy transactions
      allow read: if isOwner(resource.data.userId) ||
                     canAccessGroup(resource.data.groupIds) ||
                     (resource.data.familyId != null && inSameFamily(resource.data.familyId));

      // Only cloud functions should create Plaid transactions (from sync)
      allow create: if false;

      // Users can update limited fields on their own transactions (user notes, tags, category overrides)
      allow update: if isOwner(resource.data.userId) &&
                       isValidPlaidTransactionUpdate();

      // Only admins can delete Plaid transactions (for cleanup)
      allow delete: if isAdmin();
    }
    
    match /plaid_webhooks/{webhookId} {
      // Only admins can read webhook logs (for debugging)
      allow read: if isAdmin();
      
      // Only cloud functions should create webhook records
      allow create: if false;
      
      // Only cloud functions should update webhook processing status
      allow update: if false;
      
      // Only admins can delete webhook records (for cleanup)
      allow delete: if isAdmin();
    }
    
    match /plaid_configuration/config {
      // Only admins can read Plaid configuration
      allow read: if isAdmin();
      
      // Only admins can update Plaid configuration
      allow create, update: if isAdmin() && isValidPlaidConfigData();
      
      // Only admins can delete Plaid configuration
      allow delete: if isAdmin();
    }
    
    match /plaid_recurring_transactions/{recurringTransactionId} {
      // Group-based access: Users can read their own recurring transactions or group-shared transactions
      // Falls back to familyId for legacy transactions
      allow read: if isOwner(resource.data.userId) ||
                     canAccessGroup(resource.data.groupIds) ||
                     (resource.data.familyId != null && inSameFamily(resource.data.familyId));

      // Only cloud functions should create recurring transactions (from sync)
      allow create: if false;

      // Users can update limited fields on their own recurring transactions (user notes, tags, category overrides, visibility)
      allow update: if isOwner(resource.data.userId) &&
                       isValidPlaidRecurringTransactionUpdate();

      // Only admins can delete recurring transactions (for cleanup)
      allow delete: if isAdmin();
    }
    
    match /plaid_recurring_transaction_updates/{updateId} {
      // Only admins can read recurring transaction update logs (for debugging)
      allow read: if isAdmin();
      
      // Only cloud functions should create update records
      allow create: if false;
      
      // Only cloud functions should update processing status
      allow update: if false;
      
      // Only admins can delete update records (for cleanup)
      allow delete: if isAdmin();
    }
    
    // =======================
    // INFLOW COLLECTION RULES - ROOT LEVEL
    // =======================

    match /inflows/{inflowId} {
      // Group-based access: Users can read their own inflow streams or group-shared streams
      // Supports both FLAT (ownerId) and NESTED (userId) structure for backward compatibility
      // Falls back to familyId for legacy inflow streams
      allow read: if isOwner(resource.data.ownerId) ||
                     isOwner(resource.data.userId) ||
                     canAccessGroup(resource.data.groupIds) ||
                     (resource.data.familyId != null && inSameFamily(resource.data.familyId));

      // Only cloud functions should create inflow streams (from Plaid sync)
      allow create: if false;

      // Users can update limited fields on their own inflow streams (user notes, tags, category overrides, visibility)
      // Supports both FLAT (ownerId) and NESTED (userId) structure for backward compatibility
      allow update: if (isOwner(resource.data.ownerId) || isOwner(resource.data.userId)) &&
                       isValidRecurringIncomeUpdate();

      // Only admins can delete inflow streams (for cleanup)
      allow delete: if isAdmin();
    }

    // =======================
    // OUTFLOWS COLLECTION RULES - ROOT LEVEL
    // =======================

    match /outflows/{outflowId} {
      // Group-based access: Users can read their own outflow streams or group-shared streams
      // Supports both FLAT (ownerId) and NESTED (userId) structure for backward compatibility
      // Falls back to familyId for legacy outflow streams
      allow read: if isOwner(resource.data.ownerId) ||
                     isOwner(resource.data.userId) ||
                     canAccessGroup(resource.data.groupIds) ||
                     (resource.data.familyId != null && inSameFamily(resource.data.familyId));

      // Only cloud functions should create outflow streams (from Plaid sync)
      allow create: if false;

      // Users can update limited fields on their own outflow streams (user notes, tags, category overrides, visibility)
      // Supports both FLAT (ownerId) and NESTED (userId) structure for backward compatibility
      allow update: if (isOwner(resource.data.ownerId) || isOwner(resource.data.userId)) &&
                       isValidRecurringOutflowUpdate();

      // Only admins can delete outflow streams (for cleanup)
      allow delete: if isAdmin();
    }
    
    // =======================
    // OUTFLOW PERIODS COLLECTION RULES - ROOT LEVEL
    // =======================
    
    match /outflow_periods/{outflowPeriodId} {
      // Group-based access: Users can read their own outflow periods or group-shared periods
      // Falls back to familyId for legacy periods
      // Supports both userId (current) and ownerId (future) for backward compatibility
      // Handle case where collection/documents don't exist yet
      allow read: if resource == null ||
                     isOwner(resource.data.userId) ||
                     isOwner(resource.data.ownerId) ||
                     canAccessGroup(resource.data.groupIds) ||
                     (resource.data.familyId != null && inSameFamily(resource.data.familyId));

      // SECURE: Only allow users to list their own outflow periods or group/family outflow periods
      allow list: if isAuthenticated() &&
                     (isOwner(resource.data.userId) ||
                      isOwner(resource.data.ownerId) ||
                      canAccessGroup(resource.data.groupIds) ||
                      (resource.data.familyId != null && inSameFamily(resource.data.familyId)));

      // Only cloud functions should create outflow periods (from onOutflowCreated trigger)
      allow create: if false;

      // Users can update limited fields on their own outflow periods (user modifications, notes)
      // Allow user to modify amounts if they're the owner
      // Supports both userId (current) and ownerId (future) for backward compatibility
      allow update: if (isOwner(resource.data.userId) || isOwner(resource.data.ownerId)) &&
                       isValidOutflowPeriodUpdate();

      // Only admins can delete outflow periods (for cleanup)
      allow delete: if isAdmin();
    }

    // =======================
    // OUTFLOW SUMMARIES COLLECTION RULES - USER LEVEL
    // =======================

    match /outflowSummaries/{summaryId} {
      // Read: User's own summary (summaryId format: userId_periodType)
      allow read: if isAuthenticated() &&
                     summaryId.matches('^' + request.auth.uid + '_.*');

      // Write: Cloud Functions only
      allow create, update, delete: if false;
    }

    // =======================
    // GROUP OUTFLOW SUMMARIES COLLECTION RULES - GROUP LEVEL
    // =======================

    match /groupOutflowSummaries/{summaryId} {
      // Read: Group summary if user belongs to group
      allow read: if isAuthenticated() &&
                     userBelongsToGroupFromSummaryId(summaryId);

      // Write: Cloud Functions only
      allow create, update, delete: if false;
    }

    // =======================
    // INFLOW PERIODS COLLECTION RULES - ROOT LEVEL
    // =======================

    match /inflow_periods/{inflowPeriodId} {
      // Group-based access: Users can read their own inflow periods or group-shared periods
      // Falls back to familyId for legacy periods
      // Handle case where collection/documents don't exist yet
      allow read: if resource == null ||
                     isOwner(resource.data.userId) ||
                     canAccessGroup(resource.data.groupIds) ||
                     (resource.data.familyId != null && inSameFamily(resource.data.familyId));

      // SECURE: Only allow users to list their own inflow periods or group/family inflow periods
      // This covers cases where collection is empty or doesn't exist
      allow list: if isAuthenticated() &&
                     (isOwner(resource.data.userId) ||
                      canAccessGroup(resource.data.groupIds) ||
                      (resource.data.familyId != null && inSameFamily(resource.data.familyId)));

      // Only cloud functions should create inflow periods (from onInflowCreated trigger)
      allow create: if false;

      // Users can update limited fields on their own inflow periods (user modifications, notes)
      // Allow user to modify amounts if they're the owner
      allow update: if isOwner(resource.data.userId) &&
                       isValidInflowPeriodUpdate();

      // Only admins can delete inflow periods (for cleanup)
      allow delete: if isAdmin();
    }
    
    // Validation functions for Plaid data
    function isValidPlaidItemData() {
      let data = request.resource.data;
      return data.keys().hasAll(['itemId', 'userId', 'institutionId', 'institutionName', 'accessToken', 'products', 'status', 'isActive']) &&
             data.itemId is string && data.itemId.size() > 0 &&
             data.userId is string && data.userId.size() > 0 &&
             data.institutionId is string && data.institutionId.size() > 0 &&
             data.institutionName is string && data.institutionName.size() > 0 &&
             data.accessToken is string && data.accessToken.size() > 0 &&
             data.products is list &&
             data.status is string && data.status in ['GOOD', 'ITEM_LOGIN_REQUIRED', 'PENDING_EXPIRATION', 'EXPIRED', 'ERROR'] &&
             data.isActive is bool &&
             // Ensure familyId matches user's family if provided
             (data.familyId == null || 
              (exists(/databases/$(database)/documents/users/$(data.userId)) &&
               get(/databases/$(database)/documents/users/$(data.userId)).data.familyId == data.familyId));
    }
    
    function isValidPlaidAccountData() {
      let data = request.resource.data;
      return data.keys().hasAll(['accountId', 'itemId', 'userId', 'name', 'type', 'subtype', 'balances', 'isActive', 'isSyncEnabled', 'metadata']) &&
             data.accountId is string && data.accountId.size() > 0 &&
             data.itemId is string && data.itemId.size() > 0 &&
             data.userId is string && data.userId.size() > 0 &&
             data.name is string && data.name.size() > 0 &&
             data.type is string && data.type in ['depository', 'credit', 'loan', 'investment', 'other'] &&
             data.subtype is string &&
             data.balances is map && data.balances.keys().hasAll(['current']) &&
             data.balances.current is number &&
             data.isActive is bool &&
             data.isSyncEnabled is bool &&
             data.metadata is map &&
             // Ensure familyId matches user's family if provided
             (data.familyId == null || 
              (exists(/databases/$(database)/documents/users/$(data.userId)) &&
               get(/databases/$(database)/documents/users/$(data.userId)).data.familyId == data.familyId));
    }
    
    function isValidPlaidTransactionUpdate() {
      let data = request.resource.data;
      let resource = resource.data;
      // Only allow updates to user-modifiable fields
      let allowedFields = ['userCategory', 'userNotes', 'tags', 'isHidden', 'updatedAt'];
      let changedFields = data.diff(resource).affectedKeys();
      return changedFields.hasOnly(allowedFields);
    }
    
    function isValidPlaidRecurringTransactionUpdate() {
      let data = request.resource.data;
      let resource_data = resource.data;
      // Only allow updates to user-modifiable fields for recurring transactions
      let allowedFields = ['userCategory', 'userNotes', 'tags', 'isHidden', 'updatedAt'];
      let changedFields = data.diff(resource_data).affectedKeys();
      return changedFields.hasOnly(allowedFields);
    }
    
    // Validation functions for new root collections
    function isValidRecurringIncomeUpdate() {
      let data = request.resource.data;
      let resource_data = resource.data;
      // Only allow updates to user-modifiable fields for income streams
      let allowedFields = [
        'userCategory', 'userNotes', 'tags', 'isHidden', 'updatedAt',
        'incomeType', 'isRegularSalary', 'employerName', 'taxable'
      ];
      let changedFields = data.diff(resource_data).affectedKeys();
      return changedFields.hasOnly(allowedFields);
    }
    
    function isValidRecurringOutflowUpdate() {
      let data = request.resource.data;
      let resource_data = resource.data;
      // Only allow updates to user-modifiable fields for outflow streams
      // Supports both FLAT and NESTED structure fields for backward compatibility
      let allowedFields = [
        // Legacy nested structure fields
        'userCategory', 'userNotes', 'merchantCategory', 'isCancellable', 'reminderDays',
        // Flat structure fields
        'userCustomName', 'internalPrimaryCategory', 'internalDetailedCategory',
        // Common fields
        'tags', 'isHidden', 'expenseType', 'isEssential', 'updatedAt', 'updatedBy'
      ];
      let changedFields = data.diff(resource_data).affectedKeys();
      return changedFields.hasOnly(allowedFields);
    }
    
    // Validation function for outflow period updates
    function isValidOutflowPeriodUpdate() {
      let data = request.resource.data;
      let resource_data = resource.data;
      // Allow updates to user-modifiable fields AND multi-occurrence tracking fields
      // Multi-occurrence fields are updated by onOutflowUpdated trigger when transactionIds changes
      let allowedFields = [
        // User-modifiable fields (frontend can update these directly)
        'userNotes', 'userCustomName', 'isHidden', 'isPaid', 'isActive',
        'modifiedAmount', 'isModified', 'lastModifiedBy', 'lastModifiedAt',
        'transactionSplits', 'status', 'updatedAt',
        // Multi-occurrence tracking fields (updated by Cloud Functions)
        'occurrencePaidFlags', 'occurrenceTransactionIds',
        'numberOfOccurrencesPaid', 'numberOfOccurrencesUnpaid',
        'totalAmountPaid', 'totalAmountUnpaid',
        'paymentProgressPercentage', 'dollarProgressPercentage',
        'isFullyPaid', 'isPartiallyPaid',
        'nextUnpaidDueDate', 'amountDue',
        'lastCalculated', 'lastSyncedAt',
        // Fields updated by backend triggers (onOutflowUpdated)
        'averageAmount', 'expectedAmount', 'amountWithheld', 'totalAmountDue',
        'amountPerOccurrence', 'dailyWithholdingRate', 'description'
      ];
      let changedFields = data.diff(resource_data).affectedKeys();

      // Validate transactionSplits if they're being updated
      let splitsValid = !changedFields.hasAny(['transactionSplits']) ||
                       isValidTransactionSplitReferences(data.transactionSplits);

      // Validate status if it's being updated
      let statusValid = !changedFields.hasAny(['status']) ||
                       (data.status is string && data.status in ['pending', 'due_soon', 'partial', 'partially_paid', 'paid', 'paid_early', 'overdue']);

      // Validate occurrence tracking arrays if they're being updated
      let occurrenceArraysValid = !changedFields.hasAny(['occurrencePaidFlags', 'occurrenceTransactionIds']) ||
                                 (data.occurrencePaidFlags is list &&
                                  data.occurrenceTransactionIds is list &&
                                  data.occurrencePaidFlags.size() == data.occurrenceTransactionIds.size() &&
                                  data.occurrencePaidFlags.size() == data.numberOfOccurrencesInPeriod);

      // For simple updates (isPaid, isHidden, etc.), just check allowed fields
      // Also verify core immutable fields don't change
      return changedFields.hasOnly(allowedFields) &&
             splitsValid &&
             statusValid &&
             occurrenceArraysValid &&
             // Ensure core immutable fields don't change
             data.outflowId == resource_data.outflowId &&
             data.sourcePeriodId == resource_data.sourcePeriodId &&
             data.ownerId == resource_data.ownerId;
    }

    // Validate transaction split references array for outflow periods
    function isValidTransactionSplitReferences(splitRefs) {
      return splitRefs is list &&
             splitRefs.size() <= 50 && // Reasonable limit for payment history
             splitRefs.all(splitRef, isValidTransactionSplitReference(splitRef));
    }

    // Validate individual transaction split reference
    function isValidTransactionSplitReference(splitRef) {
      return splitRef is map &&
             splitRef.keys().hasAll(['transactionId', 'splitId', 'transactionDate', 'amount', 'description', 'paymentType', 'isAutoMatched', 'matchedAt', 'matchedBy']) &&
             splitRef.transactionId is string && splitRef.transactionId.size() > 0 &&
             splitRef.splitId is string && splitRef.splitId.size() > 0 &&
             splitRef.transactionDate is timestamp &&
             splitRef.amount is number && splitRef.amount > 0 &&
             splitRef.description is string &&
             splitRef.paymentType is string && splitRef.paymentType in ['regular', 'catch_up', 'advance', 'extra_principal'] &&
             splitRef.isAutoMatched is bool &&
             splitRef.matchedAt is timestamp &&
             splitRef.matchedBy is string && splitRef.matchedBy.size() > 0;
    }
    
    // Validation function for inflow period updates
    function isValidInflowPeriodUpdate() {
      let data = request.resource.data;
      let resource_data = resource.data;
      // Only allow updates to user-modifiable fields for inflow periods
      let allowedFields = [
        'userNotes', 'modifiedAmount', 'isModified', 'lastModifiedBy', 'lastModifiedAt', 'updatedAt'
      ];
      let changedFields = data.diff(resource_data).affectedKeys();
      return changedFields.hasOnly(allowedFields) &&
             // Ensure core immutable fields don't change
             data.inflowId == resource_data.inflowId &&
             data.periodId == resource_data.periodId &&
             data.userId == resource_data.userId &&
             data.incomeAmount == resource_data.incomeAmount &&
             data.dailyEarningRate == resource_data.dailyEarningRate;
    }
    
    function isValidPlaidConfigData() {
      let data = request.resource.data;
      return data.keys().hasAll(['clientId', 'environment', 'products', 'countryCodes', 'isActive', 'syncSettings', 'encryptionSettings', 'errorHandling']) &&
             data.clientId is string && data.clientId.size() > 0 &&
             data.environment is string && data.environment in ['sandbox', 'development', 'production'] &&
             data.products is list &&
             data.countryCodes is list &&
             data.isActive is bool &&
             data.syncSettings is map && data.syncSettings.keys().hasAll(['maxTransactionDays', 'frontendTransactionDays', 'enableWebhooks', 'enableScheduledSync']) &&
             data.encryptionSettings is map && data.encryptionSettings.keys().hasAll(['algorithm', 'keyRotationDays']) &&
             data.errorHandling is map && data.errorHandling.keys().hasAll(['maxRetries', 'retryDelayMs', 'errorReportingEnabled']);
    }
    
    // Transaction validation functions - NEW FLAT STRUCTURE
    function isValidTransactionData() {
      let data = request.resource.data;
      return data.keys().hasAll(['transactionId', 'ownerId', 'transactionDate', 'name', 'source', 'transactionStatus', 'splits']) &&
             data.transactionId is string && data.transactionId.size() > 0 &&
             data.ownerId is string && data.ownerId.size() > 0 &&
             data.transactionDate is timestamp &&
             data.name is string && data.name.size() > 0 &&
             data.source is string && data.source in ['manual', 'plaid', 'import'] &&
             data.transactionStatus is string && data.transactionStatus in ['pending', 'approved', 'declined'] &&
             data.splits is list && data.splits.size() > 0 &&
             (data.groupId == null || data.groupId is string);
    }

    // Budget validation function
    function isValidBudgetData() {
      let data = request.resource.data;
      return data.keys().hasAll(['name', 'amount', 'createdBy', 'isActive', 'isOngoing']) &&
             data.name is string && data.name.size() > 0 &&
             data.amount is number && data.amount > 0 &&
             data.createdBy is string && data.createdBy.size() > 0 &&
             data.isActive is bool &&
             data.isOngoing is bool &&
             // If isOngoing is false, budgetEndDate must be present and valid
             (data.isOngoing == true ||
              (data.keys().hasAny(['budgetEndDate']) && data.budgetEndDate is timestamp)) &&
             // Ensure budget end date is after start date if provided
             (!data.keys().hasAny(['budgetEndDate']) ||
              !data.keys().hasAny(['startDate']) ||
              data.budgetEndDate.toMillis() > data.startDate.toMillis());
    }
    
    function isValidTransactionUpdate() {
      let data = request.resource.data;
      let resource_data = resource.data;
      let changedFields = data.diff(resource_data).affectedKeys();
      
      // User-modifiable fields for transactions with embedded splits
      // Allow more flexible field updates to handle various transaction structures
      let allowedFields = [
        'userNotes',           // User notes
        'isHidden',            // Hide/show transaction
        'isRecurring',         // Mark as recurring
        'splits',              // Transaction splits array
        'isSplit',             // Split flag (calculated from splits)
        'totalAllocated',      // Total split amount (calculated)
        'unallocated',         // Unallocated amount (calculated)
        'affectedBudgets',     // Array of budget IDs
        'affectedBudgetPeriods', // Array of budget period IDs
        'primaryBudgetId',     // Primary budget ID (largest split)
        'primaryBudgetPeriodId', // Primary budget period ID (largest split)
        'updatedAt',           // Update timestamp
        // Additional fields that might be updated
        'lastSyncedAt',        // Last sync timestamp
        'tags',                // Transaction tags
        'category',            // Transaction category
        'userCategory',        // User override category
        'notes',               // Alternative notes field name
        'metadata'             // Metadata updates
      ];
      
      // Validate that only allowed fields are being changed
      let validFieldChanges = changedFields.hasOnly(allowedFields);
      
      // Prevent changing core immutable fields (if they exist)
      let coreFieldsUnchanged = (!('userId' in data) || data.userId == resource_data.userId) &&
                               (!('amount' in data) || data.amount == resource_data.amount);
      
      // For now, skip complex split validation to get basic updates working
      // We'll rely on the frontend/backend validation instead
      let splitsValid = true;
      
      return validFieldChanges && coreFieldsUnchanged && splitsValid;
    }
    
    // Validate transaction splits array
    function isValidTransactionSplitsUpdate(splits, transactionAmount) {
      return splits is list &&
             splits.size() >= 1 && // Must have at least one split
             splits.size() <= 20 && // Reasonable limit
             splits.all(splitItem, isValidTransactionSplit(splitItem)) &&
             isValidSplitAmounts(splits, transactionAmount);
    }

    // Validate individual transaction split with enhanced status fields - NEW FLAT STRUCTURE
    function isValidTransactionSplit(splitItem) {
      return splitItem is map &&
             // Core required fields - NEW NAMING
             splitItem.keys().hasAll(['splitId', 'plaidPrimaryCategory', 'amount', 'isDefault', 'createdAt', 'updatedAt']) &&
             splitItem.splitId is string && splitItem.splitId.size() > 0 &&
             splitItem.plaidPrimaryCategory is string &&
             splitItem.amount is number && splitItem.amount > 0 &&
             splitItem.isDefault is bool &&
             splitItem.createdAt is timestamp &&
             splitItem.updatedAt is timestamp &&

             // Budget assignment fields (optional for unassigned splits)
             (!splitItem.keys().hasAny(['budgetId']) || (splitItem.budgetId is string && splitItem.budgetId.size() > 0)) &&

             // Period ID fields
             (!splitItem.keys().hasAny(['monthlyPeriodId']) || (splitItem.monthlyPeriodId == null || splitItem.monthlyPeriodId is string)) &&
             (!splitItem.keys().hasAny(['weeklyPeriodId']) || (splitItem.weeklyPeriodId == null || splitItem.weeklyPeriodId is string)) &&
             (!splitItem.keys().hasAny(['biWeeklyPeriodId']) || (splitItem.biWeeklyPeriodId == null || splitItem.biWeeklyPeriodId is string)) &&

             // Status fields validation
             isValidSplitStatusFields(splitItem) &&

             // Optional fields validation
             (!splitItem.keys().hasAny(['description']) || splitItem.description is string) &&
             (!splitItem.keys().hasAny(['tags']) || splitItem.tags is list) &&
             (!splitItem.keys().hasAny(['rules']) || splitItem.rules is list);
    }

    // Enhanced validation for split status fields
    function isValidSplitStatusFields(split) {
      return (
        // Ignored status validation
        (!split.keys().hasAny(['isIgnored']) || split.isIgnored is bool) &&
        (!split.keys().hasAny(['ignoredReason']) || (split.ignoredReason is string && split.ignoredReason.size() <= 200)) &&

        // Refund status validation
        (!split.keys().hasAny(['isRefund']) || split.isRefund is bool) &&
        (!split.keys().hasAny(['refundReason']) || (split.refundReason is string && split.refundReason.size() <= 200)) &&

        // Tax deductible status validation
        (!split.keys().hasAny(['isTaxDeductible']) || split.isTaxDeductible is bool) &&
        (!split.keys().hasAny(['taxDeductibleCategory']) || (split.taxDeductibleCategory is string && split.taxDeductibleCategory.size() <= 100)) &&

        // Budget exclusion validation
        (!split.keys().hasAny(['excludedFromBudgets']) || split.excludedFromBudgets is bool) &&

        // Manual budget assignment validation
        (!split.keys().hasAny(['manualBudgetAssignment']) || split.manualBudgetAssignment is bool) &&

        // Status consistency checks
        isValidSplitStatusConsistency(split)
      );
    }

    // Validate status field consistency
    function isValidSplitStatusConsistency(split) {
      return (
        // If ignored reason is provided, isIgnored must be true
        (!split.keys().hasAny(['ignoredReason']) || split.get('isIgnored', false) == true) &&

        // If refund reason is provided, isRefund must be true
        (!split.keys().hasAny(['refundReason']) || split.get('isRefund', false) == true) &&

        // If tax deductible category is provided, isTaxDeductible must be true
        (!split.keys().hasAny(['taxDeductibleCategory']) || split.get('isTaxDeductible', false) == true)
      );
    }
    
    // Validate that split amounts don't exceed transaction amount
    function isValidSplitAmounts(splits, transactionAmount) {
      // Use a simple iteration approach since complex aggregation in .all() is tricky
      return splits.size() > 0 &&
             splits.all(splitItem, splitItem.amount > 0 && splitItem.amount <= transactionAmount * 1.1); // Allow 10% tolerance for floating point
    }
    
    // Validate budget period updates
    function isValidBudgetPeriodUpdate() {
      let data = request.resource.data;
      let resource_data = resource.data;
      
      // Allow updates to user-modifiable fields for budget periods
      let allowedFields = [
        'userNotes',           // User notes
        'modifiedAmount',      // Modified budget amount
        'isModified',          // Modification flag
        'isActive',            // Active/inactive status
        'lastModifiedBy',      // Who modified it
        'lastModifiedAt',      // When modified
        'checklistItems',      // Checklist items array
        'updatedAt'            // Update timestamp
      ];
      
      let changedFields = data.diff(resource_data).affectedKeys();
      let validFieldChanges = changedFields.hasOnly(allowedFields);
      
      // Ensure core immutable fields don't change
      let coreFieldsUnchanged = data.budgetId == resource_data.budgetId &&
                               data.periodId == resource_data.periodId &&
                               data.userId == resource_data.userId &&
                               data.allocatedAmount == resource_data.allocatedAmount &&
                               data.originalAmount == resource_data.originalAmount;
      
      // Validate checklist items if they're being updated
      let checklistValid = !changedFields.hasAny(['checklistItems']) || isValidChecklistItems(data.checklistItems);
      
      return validFieldChanges && coreFieldsUnchanged && checklistValid;
    }
    
    // Validate checklist items array
    function isValidChecklistItems(checklistItems) {
      return checklistItems is list &&
             checklistItems.size() <= 20 && // Reasonable limit
             checklistItems.all(checklistItem, isValidChecklistItem(checklistItem));
    }

    // Validate individual checklist item
    function isValidChecklistItem(checklistItem) {
      return checklistItem is map &&
             checklistItem.keys().hasAll(['id', 'name', 'transactionSplit', 'expectedAmount', 'actualAmount', 'isChecked']) &&
             checklistItem.id is string && checklistItem.id.size() > 0 &&
             checklistItem.name is string && checklistItem.name.size() > 0 && checklistItem.name.size() <= 100 &&
             checklistItem.transactionSplit is string &&
             checklistItem.expectedAmount is number && checklistItem.expectedAmount >= 0 &&
             checklistItem.actualAmount is number && checklistItem.actualAmount >= 0 &&
             checklistItem.isChecked is bool;
    }
    
    // =======================
    // BUDGET PERIODS COLLECTION RULES
    // =======================
    
    match /budget_periods/{budgetPeriodId} {
      // Group-based access: Users can read their own budget periods or group-shared budget periods
      // Falls back to familyId for legacy budget periods
      allow read: if isOwner(resource.data.userId) ||
                     canAccessGroup(resource.data.groupIds) ||
                     (resource.data.familyId != null && inSameFamily(resource.data.familyId));

      // Budget creator can always manage their own budget_periods (regardless of role)
      // OR group members can manage shared budget_periods
      // OR family managers (admin/parent) can manage any family budget_periods
      allow create, update: if (isOwner(resource.data.userId) ||
                                canAccessGroup(resource.data.groupIds) ||
                                (canManage() && resource.data.familyId != null && inSameFamily(resource.data.familyId))) &&
                               isValidBudgetPeriodUpdate();

      // Only admins can delete budget periods (for cleanup)
      allow delete: if isAdmin();
    }
    
    
    // =======================
    // CATEGORIES COLLECTION RULES
    // =======================
    
    match /categories/{categoryId} {
      // All authenticated users can read categories (universal data)
      allow read: if isAuthenticated();
      
      // Only admins can create, update, or delete categories
      allow create, update, delete: if isAdmin();
    }
    
    // =======================
    // SYSTEM COLLECTIONS
    // =======================
    
    // Admin-only collections
    match /admin/{document=**} {
      allow read, write: if isAdmin();
    }
    
    // Analytics and logs (read-only for admins)
    match /analytics/{document=**} {
      allow read: if isAdmin();
      allow write: if false; // Only cloud functions
    }
    
    match /audit_logs/{document=**} {
      allow read: if isAdmin();
      allow write: if false; // Only cloud functions
    }
    
    // Deny all other requests
    match /{document=**} {
      allow read, write: if false;
    }
  }
}